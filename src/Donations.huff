/** 
 *  DONATIONS HUFF EXERCISE
 *  
 *  The task is to Implement solidity's "receive" functionality which allows sending ether to a smart contract without any calldata
 *  also have a getter function that returns how much an address has donated. Addresses can donate several times
 */

#define function donated(address) payable returns(uint256)

#define constant DONATIONS = FREE_STORAGE_POINTER() // load location with sha3(key, [DONATIONS])

#define macro MAIN() = takes(0) returns(0) {
    0x00 calldataload
    0xe0 shr

    // dispatcher
    dup1 __FUNC_SIG(donated) eq donated jumpi
    0x00 eq receive jumpi

    0x00 0x00 revert

    donated: // [sig]
        pop // []

        // calculate slot
        0x04 calldataload 0x00 mstore // address
        [DONATIONS] 0x20 mstore // slot0
        0x40 0x00 // [size, offset]
        sha3 // [slot]

        sload // [value]
        0x00 mstore
        0x20 0x00 return

    receive: // []
        callvalue // [value]

        // calculate slot
        caller 0x00 mstore // address
        [DONATIONS] 0x20 mstore // slot0
        0x40 0x00 // [value, size, offset]
        sha3 // [value, slot]

        dup1 // [value, slot, slot]
        sload // [value, slot, oldValue]

        dup3 add // [value, slot, newValue]
        swap1 // [value, newValue, slot]
        sstore
}