
/** 
 *  SUM_ARRAY HUFF EXERCISE
 *
 * In this puzzle, the task is to simulate an array in Huff using the "exact" storage pattern as solidity. Expected functions can; 
 *      - Push numbers onto a array, 
 *      - Pop the last index from the array,
 *      - View what's stored at an index, 
 *      - Gets the length of the array, 
 *      - Write to an index if it is valid.
 *
 *      - Writes and reads outside of length revert. 
 *      - Popping off a zero length array reverts.
 *
 *  NOTICE: The contract should revert when an unrecognized function is called
 */

 #define function pushh(uint256 num) payable returns()
 #define function popp() payable returns()
 #define function read(uint256 index) payable returns(uint256)
 #define function length() payable returns(uint256)
 #define function write(uint256 index, uint256 num) payable returns()

 #define error OutOfBounds()
 #define error ZeroArray()

 #define constant STORAGE = FREE_STORAGE_POINTER()

 #define macro MAIN() = takes(0) returns(0) {
    0x00 calldataload
    0xe0 shr

    // dispatcher
    dup1 __FUNC_SIG(pushh) eq pushh jumpi
    dup1 __FUNC_SIG(popp) eq popp jumpi
    dup1 __FUNC_SIG(read) eq read jumpi
    dup1 __FUNC_SIG(length) eq length jumpi
    dup1 __FUNC_SIG(write) eq write jumpi

    0x00 0x00 revert

    pushh:
        pop // []

        // calculate target slot
        [STORAGE] sload dup1 [STORAGE] 0x00 mstore // [length, length]
        0x20 0x00 sha3 // [length, length, startSlot]
        add // [length, targetSlot]

        // push element
        0x04 calldataload swap1 // [length, value, targetSlot]
        sstore

        // update length
        0x01 add // [newLength]
        [STORAGE] // [newLength, slot0]
        sstore

        0x00 0x00 return

    popp:
        pop // []

        // calculate target slot
        [STORAGE] sload dup1 [STORAGE] 0x00 mstore // [length, length]
        0x20 0x00 sha3 // [length, length, startSlot]
        add 0x01 swap1 sub // [length, targetSlot]

        // check if length == 0
        dup2 0x00 eq lengthZero jumpi

        // pop element
        0x00 swap1 // [length, 0, targetSlot]
        sstore

        // update length
        0x01 swap1 sub // [newLength]
        [STORAGE] // [newLength, slot0]
        sstore

        0x00 0x00 return

        lengthZero:
            __ERROR(ZeroArray) 0x00 mstore
            0x04 0x00 revert

    read:
        pop // []

        // check if index + 1 > length
        [STORAGE] [STORAGE] sload // [slot0, length]
        0x04 calldataload 0x01 add gt outOfBounds jumpi // [slot0]

        // calculate target slot and read the element
        0x00 mstore // []
        0x20 0x00 sha3 // [slot0]
        0x04 calldataload // [slot0, index]
        add // [targetSlot]
        sload // [element]

        0x00 mstore
        0x20 0x00 return

        outOfBounds:
            __ERROR(OutOfBounds) 0x00 mstore
            0x04 0x00 revert

    length:
        pop // []
        [STORAGE] sload
        0x00 mstore
        0x20 0x00 return

    write:
        pop // []

        // check if index + 1 > length
        [STORAGE] [STORAGE] sload // [slot0, length]
        0x04 calldataload 0x01 add gt outOfBounds jumpi // [slot0]

        // calculate target slot
        0x00 mstore
        0x20 0x00 sha3 // [slot0]
        0x04 calldataload // [slot0, index]
        add // [targetSlot]

        // write to slot
        0x24 calldataload swap1 // [value, targetSlot]
        sstore

        0x00 0x00 return

        outOfBounds:
            __ERROR(OutOfBounds) 0x00 mstore
            0x04 0x00 revert
 }